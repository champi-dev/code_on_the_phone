<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta name="theme-color" content="#0d1117" />
    <title>Terminal 3D</title>
    <link rel="manifest" href="/manifest.json" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="alternate icon" href="/favicon.ico" />
    <link rel="apple-touch-icon" href="/icon.svg" />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        background-color: #0d1117;
        color: #c9d1d9;
        overflow: hidden;
        position: fixed;
        width: 100%;
        height: 100%;
      }

      #three-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
        pointer-events: none;
        background: radial-gradient(
          ellipse at center,
          #1a1f2e 0%,
          #0d1117 100%
        );
      }

      /* Additional background effects */
      #three-container::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(
            circle at 20% 50%,
            rgba(122, 162, 247, 0.1) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 80% 80%,
            rgba(187, 154, 247, 0.1) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 40% 20%,
            rgba(158, 206, 106, 0.05) 0%,
            transparent 50%
          );
        animation: bgShift 20s ease-in-out infinite;
      }

      @keyframes bgShift {
        0%,
        100% {
          transform: translate(0, 0) scale(1);
        }
        33% {
          transform: translate(-20px, -20px) scale(1.1);
        }
        66% {
          transform: translate(20px, -10px) scale(0.9);
        }
      }

      .terminal-wrapper {
        position: relative;
        z-index: 10;
        height: 100vh;
        display: flex;
        flex-direction: column;
      }

      .terminal-header {
        background: rgba(22, 27, 34, 0.95);
        backdrop-filter: blur(10px);
        display: flex;
        flex-direction: column;
        border-bottom: 1px solid rgba(48, 54, 61, 0.5);
        z-index: 20;
      }

      .terminal-top-bar {
        padding: 12px 16px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        height: 50px;
      }

      .tabs-container {
        display: flex;
        align-items: center;
        padding: 0 16px;
        gap: 8px;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: thin;
        scrollbar-color: rgba(122, 162, 247, 0.3) transparent;
      }

      .tabs-container::-webkit-scrollbar {
        height: 4px;
      }

      .tabs-container::-webkit-scrollbar-track {
        background: transparent;
      }

      .tabs-container::-webkit-scrollbar-thumb {
        background: rgba(122, 162, 247, 0.3);
        border-radius: 2px;
      }

      .tab {
        background: rgba(33, 38, 45, 0.6);
        border: 1px solid rgba(48, 54, 61, 0.5);
        border-radius: 8px 8px 0 0;
        padding: 8px 16px;
        display: flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
        transition: all 0.2s;
        position: relative;
        min-width: 120px;
        max-width: 200px;
        flex-shrink: 0;
      }

      .tab.active {
        background: rgba(48, 54, 61, 0.8);
        border-color: #7aa2f7;
        border-bottom: 1px solid transparent;
      }

      .tab:hover {
        background: rgba(48, 54, 61, 0.7);
      }

      .tab-title {
        flex: 1;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        font-size: 13px;
      }

      .tab-close {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: rgba(248, 81, 73, 0.2);
        border: 1px solid rgba(248, 81, 73, 0.3);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s;
        font-size: 10px;
        color: #f85149;
      }

      .tab-close:hover {
        background: rgba(248, 81, 73, 0.4);
        transform: scale(1.1);
      }

      .add-tab-btn {
        background: rgba(122, 162, 247, 0.1);
        border: 1px solid rgba(122, 162, 247, 0.3);
        border-radius: 6px;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s;
        flex-shrink: 0;
        color: #7aa2f7;
        font-size: 18px;
      }

      .add-tab-btn:hover {
        background: rgba(122, 162, 247, 0.2);
        transform: scale(1.05);
      }

      .terminal-title {
        font-size: 16px;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .glow-orb {
        width: 10px;
        height: 10px;
        background: radial-gradient(circle, #7aa2f7 0%, #bb9af7 100%);
        border-radius: 50%;
        animation: pulse 2s ease-in-out infinite;
        box-shadow: 0 0 20px rgba(122, 162, 247, 0.8);
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
          transform: scale(1);
        }
        50% {
          opacity: 0.8;
          transform: scale(1.2);
        }
      }

      .performance-monitor {
        font-size: 11px;
        font-family: "SF Mono", Monaco, monospace;
        color: #9ece6a;
        background: rgba(26, 27, 38, 0.8);
        padding: 4px 8px;
        border-radius: 4px;
        display: flex;
        gap: 10px;
      }

      .fps-counter {
        color: #7aa2f7;
      }

      .terminal-container {
        opacity: 0.6;
        flex: 1;
        position: relative;
        background: rgba(13, 17, 23, 0.85);
        backdrop-filter: blur(5px);
        animation: terminalGlow 4s ease-in-out infinite alternate;
        margin-bottom: 60px; /* Account for quick-bar */
        overflow: hidden; /* Prevent iframe from overflowing */
      }

      #terminals-container {
        width: 100%;
        height: 100%;
        position: relative;
        overflow: hidden; /* Ensure iframes stay within bounds */
      }

      @keyframes terminalGlow {
        0% {
          box-shadow: inset 0 0 20px rgba(122, 162, 247, 0.05);
        }
        100% {
          box-shadow: inset 0 0 30px rgba(187, 154, 247, 0.08);
        }
      }

      #terminal-frame {
        width: 100%;
        height: 100%;
        border: none;
        background: transparent;
        position: relative;
      }

      /* Terminal text animation overlay */
      .terminal-fx {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 5;
        overflow: hidden;
      }

      .terminal-fx::before {
        content: "";
        position: absolute;
        top: -100%;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          0deg,
          transparent 0%,
          rgba(122, 162, 247, 0.03) 50%,
          transparent 100%
        );
        animation: scanline 8s linear infinite;
      }

      @keyframes scanline {
        to {
          top: 100%;
        }
      }

      /* Subtle text distortion effect */
      .terminal-fx::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: repeating-linear-gradient(
          0deg,
          transparent,
          transparent 2px,
          rgba(255, 255, 255, 0.01) 2px,
          rgba(255, 255, 255, 0.01) 4px
        );
        animation: flicker 0.15s infinite;
      }

      @keyframes flicker {
        0% {
          opacity: 0.97;
        }
        50% {
          opacity: 1;
        }
        100% {
          opacity: 0.98;
        }
      }

      /* Removed quick-bar styles */

      .loading-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #0d1117;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        transition: opacity 0.5s;
      }

      .loading-content {
        text-align: center;
      }

      .loading-spinner {
        width: 60px;
        height: 60px;
        position: relative;
        margin: 0 auto 20px;
      }

      .loading-spinner::before,
      .loading-spinner::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border-radius: 50%;
        border: 3px solid transparent;
        border-top-color: #7aa2f7;
        animation: spin 1.5s linear infinite;
      }

      .loading-spinner::after {
        border-top-color: #bb9af7;
        animation-delay: 0.2s;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .logout-btn {
        background: rgba(248, 81, 73, 0.1);
        border: 1px solid rgba(248, 81, 73, 0.3);
        border-radius: 6px;
        padding: 6px 12px;
        color: #f85149;
        font-size: 12px;
        cursor: pointer;
        transition: all 0.2s;
      }

      .logout-btn:hover {
        background: rgba(248, 81, 73, 0.2);
        border-color: #f85149;
      }

      /* PWA install prompt */
      .install-prompt {
        position: fixed;
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(33, 38, 45, 0.95);
        border: 1px solid rgba(122, 162, 247, 0.5);
        border-radius: 12px;
        padding: 16px 20px;
        display: none;
        align-items: center;
        gap: 12px;
        backdrop-filter: blur(10px);
        box-shadow: 0 4px 24px rgba(0, 0, 0, 0.4);
        z-index: 100;
      }

      .install-prompt button {
        background: linear-gradient(135deg, #7aa2f7 0%, #bb9af7 100%);
        border: none;
        border-radius: 6px;
        padding: 8px 16px;
        color: white;
        font-weight: 500;
        cursor: pointer;
      }

      /* Quick bar styles */
      .quick-bar {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: rgba(22, 27, 34, 0.95);
        backdrop-filter: blur(10px);
        border-top: 1px solid rgba(48, 54, 61, 0.5);
        padding: 8px;
        display: flex;
        gap: 8px;
        overflow-x: auto;
        height: 60px;
        align-items: center;
        -webkit-overflow-scrolling: touch;
        z-index: 30; /* Higher than terminal-header (20) */
      }

      .quick-btn {
        background: rgba(33, 38, 45, 0.6);
        border: 1px solid rgba(48, 54, 61, 0.5);
        border-radius: 6px;
        padding: 8px 16px;
        color: #c9d1d9;
        font-size: 13px;
        white-space: nowrap;
        cursor: pointer;
        transition: all 0.2s;
        flex-shrink: 0;
      }

      .quick-btn:hover {
        background: rgba(48, 54, 61, 0.7);
        border-color: rgba(122, 162, 247, 0.5);
      }

      .quick-btn:active {
        transform: scale(0.95);
      }

      @media (max-width: 640px) {
        .terminal-title {
          font-size: 14px;
        }

        .quick-btn {
          padding: 6px 12px;
          font-size: 12px;
        }
      }
    </style>
    <script src="/js/three.min.js"></script>
    <script src="/js/terminal-persistence.js"></script>
    <script src="/js/wake-lock.js"></script>
  </head>
  <body>
    <div class="loading-screen" id="loadingScreen">
      <div class="loading-content">
        <div class="loading-spinner"></div>
        <div style="color: #8b949e">Initializing quantum terminal...</div>
      </div>
    </div>

    <div id="three-container"></div>

    <div class="terminal-wrapper">
      <div class="terminal-header">
        <div class="terminal-top-bar">
          <div class="terminal-title">
            <div class="glow-orb"></div>
            Cloud Terminal 3D
          </div>
          <div style="display: flex; gap: 12px; align-items: center">
            <div class="performance-monitor">
              <span>O(1)</span>
              <span class="fps-counter" id="fpsCounter">120 FPS</span>
            </div>
            <button class="logout-btn" onclick="logout()">Logout</button>
          </div>
        </div>
        <div class="tabs-container" id="tabs-container">
          <!-- Tabs will be dynamically added here -->
          <div class="add-tab-btn" onclick="addNewTab()" title="New Tab">+</div>
        </div>
      </div>

      <div class="terminal-container">
        <div
          id="terminals-container"
          style="width: 100%; height: 100%; position: relative"
        >
          <!-- Terminal iframes will be dynamically added here -->
        </div>
        <div class="terminal-fx"></div>
      </div>

      <!-- Quick bar with mobile controls -->
      <div class="quick-bar">
        <button class="quick-btn" onclick="sendCmd('\x03')">Ctrl+C</button>
        <button class="quick-btn" onclick="sendCmd('\x1b')">Esc</button>
        <button class="quick-btn" onclick="sendCmd('\x1b[A')">↑</button>
        <button class="quick-btn" onclick="sendCmd('\x1b[B')">↓</button>
        <button class="quick-btn" onclick="sendCmd('\x1b[D')">←</button>
        <button class="quick-btn" onclick="sendCmd('\x1b[C')">→</button>
        <button class="quick-btn" onclick="sendCmd('clear\n')">Clear</button>
        <button class="quick-btn" onclick="sendCmd('tmux new-window\n')">New Tab</button>
      </div>
    </div>

    <div class="install-prompt" id="installPrompt">
      <span>Install Cloud Terminal as an app?</span>
      <button onclick="installPWA()">Install</button>
      <button
        onclick="dismissInstall()"
        style="background: transparent; border: 1px solid #30363d"
      >
        Later
      </button>
    </div>

    <script>
      // Three.js Background Animation
      let scene,
        camera,
        renderer,
        particles,
        frameCount = 0;
      let mouseX = 0,
        mouseY = 0;
      let geometries = [];
      let materials = [];
      let meshes = [];
      let particleSystems = [];
      let time = 0;
      
      // Award-winning animation systems
      let galaxySystem = null;
      let quantumField = null;
      let holographicDisplay = null;
      let neuralNetwork = null;
      let matrixRain = null;
      let commandEffects = new Map();
      let activeEffects = [];

      function initThree() {
        console.log("initThree called, creating scene...");
        try {
          // Detect platform and adjust performance
          const isLinux = navigator.platform.toLowerCase().indexOf('linux') !== -1;
          const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
          const isLowEnd = isLinux || isMobile || navigator.hardwareConcurrency <= 4;
          
          console.log(`Platform: ${navigator.platform}, Low-end mode: ${isLowEnd}`);
          
          scene = new THREE.Scene();
          scene.fog = new THREE.Fog(0x0d1117, 1, 15);

          camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
          );

          renderer = new THREE.WebGLRenderer({ 
            alpha: true, 
            antialias: !isLowEnd, // Disable antialiasing on low-end
            powerPreference: isLowEnd ? "low-power" : "high-performance",
            stencil: false,
            depth: true
          });
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.setPixelRatio(Math.min(window.devicePixelRatio, isLowEnd ? 1 : 2));
          renderer.toneMapping = isLowEnd ? THREE.NoToneMapping : THREE.ACESFilmicToneMapping;
          renderer.toneMappingExposure = 1.2;
          renderer.shadowMap.enabled = false; // Disable shadows for performance
          renderer.sortObjects = false; // Disable automatic sorting for performance
          document
            .getElementById("three-container")
            .appendChild(renderer.domElement);

          // Create multiple particle systems with different behaviors
          // System 1: Floating particles
          const particleCount1 = isLowEnd ? 500 : 1500; // Reduced for low-end systems
          const geometry1 = new THREE.BufferGeometry();
          const positions1 = new Float32Array(particleCount1 * 3);
          const colors1 = new Float32Array(particleCount1 * 3);
          const sizes1 = new Float32Array(particleCount1);

          for (let i = 0; i < particleCount1; i++) {
            const i3 = i * 3;
            positions1[i3] = (Math.random() - 0.5) * 20;
            positions1[i3 + 1] = (Math.random() - 0.5) * 20;
            positions1[i3 + 2] = (Math.random() - 0.5) * 20;

            const color = new THREE.Color();
            color.setHSL(0.6 + Math.random() * 0.3, 0.7, 0.5);
            colors1[i3] = color.r;
            colors1[i3 + 1] = color.g;
            colors1[i3 + 2] = color.b;

            sizes1[i] = Math.random() * 0.02 + 0.005;
          }

          geometry1.setAttribute(
            "position",
            new THREE.BufferAttribute(positions1, 3)
          );
          geometry1.setAttribute(
            "color",
            new THREE.BufferAttribute(colors1, 3)
          );
          geometry1.setAttribute("size", new THREE.BufferAttribute(sizes1, 1));

          const material1 = new THREE.PointsMaterial({
            size: 0.02,
            vertexColors: true,
            transparent: true,
            opacity: 0.6,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            sizeAttenuation: false, // Better performance
          });

          const particles1 = new THREE.Points(geometry1, material1);
          scene.add(particles1);
          particleSystems.push(particles1);

          // System 2: Energy field
          const particleCount2 = isLowEnd ? 100 : 300; // Reduced for low-end systems
          const geometry2 = new THREE.BufferGeometry();
          const positions2 = new Float32Array(particleCount2 * 3);

          for (let i = 0; i < particleCount2; i++) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(Math.random() * 2 - 1);
            const r = 3 + Math.random() * 2;

            positions2[i * 3] = r * Math.sin(phi) * Math.cos(theta);
            positions2[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            positions2[i * 3 + 2] = r * Math.cos(phi);
          }

          geometry2.setAttribute(
            "position",
            new THREE.BufferAttribute(positions2, 3)
          );

          const material2 = new THREE.PointsMaterial({
            size: 0.03,
            color: 0xbb9af7,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            map: createGlowTexture(),
            sizeAttenuation: false, // Better performance
            depthWrite: false,
          });

          const particles2 = new THREE.Points(geometry2, material2);
          scene.add(particles2);
          particleSystems.push(particles2);

          // Add dynamic geometries
          // Morphing torus knot - reduced complexity for performance
          const torusGeometry = new THREE.TorusKnotGeometry(1.5, 0.4, 100, 16);
          const torusMaterial = new THREE.MeshBasicMaterial({
            color: 0x7aa2f7,
            wireframe: true,
            transparent: true,
            opacity: 0.15,
          });
          const torusKnot = new THREE.Mesh(torusGeometry, torusMaterial);
          scene.add(torusKnot);
          meshes.push(torusKnot);

          // Icosahedron with glow
          const icoGeometry = new THREE.IcosahedronGeometry(2, 1);
          const icoMaterial = new THREE.MeshBasicMaterial({
            color: 0xbb9af7,
            wireframe: true,
            transparent: true,
            opacity: 0.1,
          });
          const icosahedron = new THREE.Mesh(icoGeometry, icoMaterial);
          icosahedron.position.x = -3;
          scene.add(icosahedron);
          meshes.push(icosahedron);

          // DNA-like helix
          const helixPoints = [];
          for (let i = 0; i < 100; i++) {
            const t = (i / 100) * Math.PI * 4;
            const x = Math.sin(t) * 2;
            const y = (i - 50) * 0.1;
            const z = Math.cos(t) * 2;
            helixPoints.push(new THREE.Vector3(x, y, z));
          }

          const helixGeometry = new THREE.BufferGeometry().setFromPoints(
            helixPoints
          );
          const helixMaterial = new THREE.LineBasicMaterial({
            color: 0x9ece6a,
            transparent: true,
            opacity: 0.3,
          });
          const helix = new THREE.Line(helixGeometry, helixMaterial);
          helix.position.x = 3;
          scene.add(helix);
          meshes.push(helix);

          // Plasma sphere - reduced complexity
          const sphereGeometry = new THREE.SphereGeometry(1, 20, 20);
          const sphereMaterial = new THREE.MeshBasicMaterial({
            color: 0xff9e64,
            wireframe: true,
            transparent: true,
            opacity: 0.1,
          });
          const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
          sphere.position.y = -2;
          scene.add(sphere);
          meshes.push(sphere);

          camera.position.z = 5;
          camera.position.y = 1;
          
          // Initialize award-winning animation systems
          createGalaxySystem();
          createQuantumField();
          createHolographicDisplay();
          createNeuralNetwork();
          createMatrixRain();

          // Mouse movement
          document.addEventListener("mousemove", (e) => {
            mouseX = (e.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
          });

          // Touch support
          document.addEventListener("touchmove", (e) => {
            if (e.touches.length > 0) {
              mouseX = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
              mouseY = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
            }
          });

          animate();
          console.log("Three.js initialization complete");
        } catch (error) {
          console.error("Error initializing Three.js:", error);
        }
      }

      function createGlowTexture() {
        const canvas = document.createElement("canvas");
        canvas.width = 32;
        canvas.height = 32;
        const ctx = canvas.getContext("2d");

        const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
        gradient.addColorStop(0, "rgba(255,255,255,1)");
        gradient.addColorStop(0.2, "rgba(255,255,255,0.8)");
        gradient.addColorStop(0.4, "rgba(122,162,247,0.6)");
        gradient.addColorStop(1, "rgba(122,162,247,0)");

        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 32, 32);

        const texture = new THREE.CanvasTexture(canvas);
        return texture;
      }
      
      // Award-winning 3D animation systems
      function createGalaxySystem() {
        const isLinux = navigator.platform.toLowerCase().indexOf('linux') !== -1;
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isLowEnd = isLinux || isMobile || navigator.hardwareConcurrency <= 4;
        
        const galaxyGeometry = new THREE.BufferGeometry();
        const galaxyCount = isLowEnd ? 10000 : 50000; // Significantly reduced for low-end
        const positions = new Float32Array(galaxyCount * 3);
        const colors = new Float32Array(galaxyCount * 3);
        const sizes = new Float32Array(galaxyCount);
        
        for (let i = 0; i < galaxyCount; i++) {
          const i3 = i * 3;
          const angle = Math.random() * Math.PI * 2;
          const radius = Math.random() * 15;
          const spinAngle = radius * 0.5;
          
          positions[i3] = Math.cos(angle + spinAngle) * radius;
          positions[i3 + 1] = (Math.random() - 0.5) * 2 * Math.exp(-radius / 10);
          positions[i3 + 2] = Math.sin(angle + spinAngle) * radius;
          
          const color = new THREE.Color();
          color.setHSL(0.6 + (radius / 15) * 0.4, 0.8, 0.6);
          colors[i3] = color.r;
          colors[i3 + 1] = color.g;
          colors[i3 + 2] = color.b;
          
          sizes[i] = Math.random() * 0.03 + 0.01;
        }
        
        galaxyGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        galaxyGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        galaxyGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        
        const galaxyMaterial = new THREE.PointsMaterial({
          size: 0.02,
          vertexColors: true,
          transparent: true,
          opacity: 0.8,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
          map: createGlowTexture()
        });
        
        galaxySystem = new THREE.Points(galaxyGeometry, galaxyMaterial);
        galaxySystem.visible = false;
        scene.add(galaxySystem);
      }
      
      function createQuantumField() {
        const fieldGeometry = new THREE.PlaneGeometry(30, 30, 64, 64);
        const fieldMaterial = new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0 },
            mousePos: { value: new THREE.Vector2(0, 0) }
          },
          vertexShader: `
            uniform float time;
            uniform vec2 mousePos;
            varying vec2 vUv;
            varying float vElevation;
            
            void main() {
              vUv = uv;
              vec3 pos = position;
              
              float dist = length(uv - mousePos);
              float wave = sin(dist * 10.0 - time * 3.0) * 0.5;
              float quantum = sin(pos.x * 2.0 + time) * cos(pos.y * 2.0 + time) * 0.3;
              
              pos.z = wave + quantum;
              vElevation = pos.z;
              
              gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
          `,
          fragmentShader: `
            uniform float time;
            varying vec2 vUv;
            varying float vElevation;
            
            void main() {
              vec3 color1 = vec3(0.48, 0.63, 0.97);
              vec3 color2 = vec3(0.73, 0.60, 0.97);
              vec3 color3 = vec3(0.62, 0.81, 0.42);
              
              float mixFactor = (sin(time * 0.5) + 1.0) * 0.5;
              vec3 mixedColor = mix(color1, color2, vElevation + 0.5);
              mixedColor = mix(mixedColor, color3, mixFactor * 0.3);
              
              float alpha = 0.3 + vElevation * 0.3;
              gl_FragColor = vec4(mixedColor, alpha);
            }
          `,
          transparent: true,
          side: THREE.DoubleSide,
          depthWrite: false
        });
        
        quantumField = new THREE.Mesh(fieldGeometry, fieldMaterial);
        quantumField.rotation.x = -Math.PI / 2;
        quantumField.position.y = -3;
        quantumField.visible = false;
        scene.add(quantumField);
      }
      
      function createHolographicDisplay() {
        const hologramGroup = new THREE.Group();
        
        // Create holographic text planes
        const textGeometry = new THREE.PlaneGeometry(8, 2);
        const hologramMaterial = new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0 },
            opacity: { value: 0.8 }
          },
          vertexShader: `
            varying vec2 vUv;
            void main() {
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform float time;
            uniform float opacity;
            varying vec2 vUv;
            
            void main() {
              vec3 color = vec3(0.0, 1.0, 0.8);
              float scanline = sin(vUv.y * 100.0 + time * 5.0) * 0.1 + 0.9;
              float glitch = step(0.98, sin(time * 20.0)) * 0.05;
              
              vec3 finalColor = color * scanline;
              float alpha = opacity * (1.0 - glitch) * (0.5 + sin(vUv.x * 10.0 + time * 2.0) * 0.5);
              
              gl_FragColor = vec4(finalColor, alpha);
            }
          `,
          transparent: true,
          side: THREE.DoubleSide,
          depthWrite: false
        });
        
        for (let i = 0; i < 5; i++) {
          const plane = new THREE.Mesh(textGeometry, hologramMaterial.clone());
          plane.position.set(
            Math.cos(i * Math.PI * 2 / 5) * 4,
            Math.sin(i * 2) * 0.5,
            Math.sin(i * Math.PI * 2 / 5) * 4
          );
          plane.lookAt(0, 0, 0);
          hologramGroup.add(plane);
        }
        
        holographicDisplay = hologramGroup;
        holographicDisplay.visible = false;
        scene.add(holographicDisplay);
      }
      
      function createNeuralNetwork() {
        const nodeCount = 50;
        const nodes = [];
        const connections = [];
        
        // Create nodes
        const nodeGeometry = new THREE.SphereGeometry(0.1, 16, 16);
        const nodeMaterial = new THREE.MeshBasicMaterial({
          color: 0x00ff88,
          emissive: 0x00ff88,
          emissiveIntensity: 0.5
        });
        
        for (let i = 0; i < nodeCount; i++) {
          const node = new THREE.Mesh(nodeGeometry, nodeMaterial.clone());
          node.position.set(
            (Math.random() - 0.5) * 10,
            (Math.random() - 0.5) * 10,
            (Math.random() - 0.5) * 10
          );
          nodes.push(node);
        }
        
        // Create connections
        const connectionMaterial = new THREE.LineBasicMaterial({
          color: 0x00ff88,
          transparent: true,
          opacity: 0.3
        });
        
        for (let i = 0; i < nodeCount; i++) {
          for (let j = i + 1; j < nodeCount; j++) {
            if (Math.random() < 0.1) {
              const points = [nodes[i].position, nodes[j].position];
              const geometry = new THREE.BufferGeometry().setFromPoints(points);
              const line = new THREE.Line(geometry, connectionMaterial);
              connections.push({ line, nodes: [i, j] });
            }
          }
        }
        
        const networkGroup = new THREE.Group();
        nodes.forEach(node => networkGroup.add(node));
        connections.forEach(conn => networkGroup.add(conn.line));
        
        neuralNetwork = { group: networkGroup, nodes, connections };
        neuralNetwork.group.visible = false;
        scene.add(neuralNetwork.group);
      }
      
      function createMatrixRain() {
        const rainGroup = new THREE.Group();
        const columnCount = 50;
        const dropCount = 20;
        
        for (let i = 0; i < columnCount; i++) {
          for (let j = 0; j < dropCount; j++) {
            const textGeometry = new THREE.PlaneGeometry(0.3, 0.3);
            const textMaterial = new THREE.MeshBasicMaterial({
              color: new THREE.Color(0, 1, 0),
              transparent: true,
              opacity: 1 - (j / dropCount),
              side: THREE.DoubleSide
            });
            
            const textMesh = new THREE.Mesh(textGeometry, textMaterial);
            textMesh.position.set(
              (i - columnCount / 2) * 0.5,
              10 - j * 0.5,
              -5
            );
            
            textMesh.userData = {
              column: i,
              row: j,
              speed: 0.1 + Math.random() * 0.1
            };
            
            rainGroup.add(textMesh);
          }
        }
        
        matrixRain = rainGroup;
        matrixRain.visible = false;
        scene.add(matrixRain);
      }
      
      // Command-triggered effects
      function triggerCommandEffect(command) {
        const cmd = command.toLowerCase().trim();
        
        if (cmd.includes('git')) {
          activateEffect('galaxy');
        } else if (cmd.includes('npm') || cmd.includes('node')) {
          activateEffect('quantum');
        } else if (cmd.includes('ssh') || cmd.includes('connect')) {
          activateEffect('hologram');
        } else if (cmd.includes('python') || cmd.includes('ai')) {
          activateEffect('neural');
        } else if (cmd.includes('hack') || cmd.includes('sudo')) {
          activateEffect('matrix');
        } else if (cmd === 'clear') {
          deactivateAllEffects();
        }
      }
      
      function activateEffect(effectName) {
        // Deactivate previous effects smoothly
        activeEffects.forEach(effect => {
          if (effect !== effectName) {
            deactivateEffect(effect);
          }
        });
        
        switch (effectName) {
          case 'galaxy':
            if (galaxySystem) {
              galaxySystem.visible = true;
              activeEffects.push('galaxy');
            }
            break;
          case 'quantum':
            if (quantumField) {
              quantumField.visible = true;
              activeEffects.push('quantum');
            }
            break;
          case 'hologram':
            if (holographicDisplay) {
              holographicDisplay.visible = true;
              activeEffects.push('hologram');
            }
            break;
          case 'neural':
            if (neuralNetwork) {
              neuralNetwork.group.visible = true;
              activeEffects.push('neural');
            }
            break;
          case 'matrix':
            if (matrixRain) {
              matrixRain.visible = true;
              activeEffects.push('matrix');
            }
            break;
        }
      }
      
      function deactivateEffect(effectName) {
        switch (effectName) {
          case 'galaxy':
            if (galaxySystem) galaxySystem.visible = false;
            break;
          case 'quantum':
            if (quantumField) quantumField.visible = false;
            break;
          case 'hologram':
            if (holographicDisplay) holographicDisplay.visible = false;
            break;
          case 'neural':
            if (neuralNetwork) neuralNetwork.group.visible = false;
            break;
          case 'matrix':
            if (matrixRain) matrixRain.visible = false;
            break;
        }
        activeEffects = activeEffects.filter(e => e !== effectName);
      }
      
      function deactivateAllEffects() {
        ['galaxy', 'quantum', 'hologram', 'neural', 'matrix'].forEach(effect => {
          deactivateEffect(effect);
        });
        activeEffects = [];
      }

      // Optimized animation variables
      let animationId;
      const isLinux = navigator.platform.toLowerCase().indexOf('linux') !== -1;
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      const isLowEnd = isLinux || isMobile || navigator.hardwareConcurrency <= 4;
      const targetFPS = isLowEnd ? 30 : 60; // Lower FPS for low-end systems
      const frameDuration = 1000 / targetFPS;
      let lastFrameTime = 0;
      let deltaTime = 0;
      
      // Pre-calculate base positions for particles
      const particleBasePositions = new Map();
      
      function animate(currentTime) {
        animationId = requestAnimationFrame(animate);
        
        // Frame rate limiting
        if (!currentTime) currentTime = performance.now();
        deltaTime = currentTime - lastFrameTime;
        if (deltaTime < frameDuration) return;
        
        lastFrameTime = currentTime - (deltaTime % frameDuration);
        frameCount++;
        time += 0.01;

        // Animate particle systems with optimized approach
        if (particleSystems[0]) {
          particleSystems[0].rotation.y += 0.0003;
          particleSystems[0].rotation.x += 0.0002;

          // Store base positions on first frame
          if (!particleBasePositions.has(particleSystems[0])) {
            const positions = particleSystems[0].geometry.attributes.position.array;
            particleBasePositions.set(particleSystems[0], new Float32Array(positions));
          }

          // Optimized wave motion - only update every 2 frames
          if (frameCount % 2 === 0) {
            const positions = particleSystems[0].geometry.attributes.position.array;
            const basePos = particleBasePositions.get(particleSystems[0]);
            const waveAmplitudeY = 0.02;
            const waveAmplitudeX = 0.01;
            
            for (let i = 0; i < positions.length; i += 3) {
              const x = basePos[i];
              const z = basePos[i + 2];
              
              positions[i] = basePos[i] + Math.sin(time * 0.7 + z * 0.3) * waveAmplitudeX;
              positions[i + 1] = basePos[i + 1] + Math.sin(time + x * 0.5) * waveAmplitudeY;
            }
            particleSystems[0].geometry.attributes.position.needsUpdate = true;
          }
        }

        if (particleSystems[1]) {
          // Energy field rotation and pulsing - optimized
          particleSystems[1].rotation.y += 0.002;
          particleSystems[1].rotation.z += 0.001;
          // Only update scale every 3 frames
          if (frameCount % 3 === 0) {
            particleSystems[1].scale.setScalar(1 + Math.sin(time * 2) * 0.1);
          }
        }

        // Animate meshes - optimized with reduced calculations
        meshes.forEach((mesh, index) => {
          if (index === 0) {
            // Torus knot
            mesh.rotation.x += 0.003;
            mesh.rotation.y += 0.002;
            if (frameCount % 2 === 0) {
              mesh.scale.setScalar(1 + Math.sin(time * 1.5) * 0.1);
            }
          } else if (index === 1) {
            // Icosahedron
            mesh.rotation.x += 0.002;
            mesh.rotation.y -= 0.003;
            if (frameCount % 2 === 0) {
              mesh.position.y = Math.sin(time) * 0.5;
            }
          } else if (index === 2) {
            // Helix
            mesh.rotation.y += 0.01;
            if (frameCount % 3 === 0) {
              mesh.position.y = Math.sin(time * 0.8) * 0.3;
            }
          } else if (index === 3) {
            // Sphere
            mesh.rotation.x += 0.004;
            mesh.rotation.z += 0.003;
            if (frameCount % 2 === 0) {
              const scale = 1 + Math.sin(time * 3) * 0.2;
              mesh.scale.setScalar(scale);
            }
          }
        });

        // Optimized camera movement with lerping
        const targetX = Math.sin(time * 0.3) * 0.5 + mouseX * 0.5;
        const targetY = Math.cos(time * 0.2) * 0.3 + mouseY * 0.5 + 1;
        camera.position.x += (targetX - camera.position.x) * 0.1;
        camera.position.y += (targetY - camera.position.y) * 0.1;
        camera.lookAt(0, 0, 0);

        // Optimized color changes - less frequent updates
        if (frameCount % 120 === 0) {
          meshes.forEach((mesh, index) => {
            if (mesh.material && mesh.material.color) {
              const hue = (time * 0.1 + index * 0.25) % 1;
              mesh.material.color.setHSL(hue, 0.7, 0.5);
            }
          });
        }

        // Optimized FPS counter
        if (frameCount % 30 === 0) {
          const currentFPS = Math.round(1000 / (deltaTime || 16.67));
          const fpsElement = document.getElementById("fpsCounter");
          if (fpsElement) {
            fpsElement.textContent = `${Math.min(currentFPS, 120)} FPS`;
          }
        }
        
        // Animate award-winning effects
        if (galaxySystem && galaxySystem.visible) {
          galaxySystem.rotation.y += 0.0005;
          // Pulsing galaxy effect
          const galaxyPositions = galaxySystem.geometry.attributes.position.array;
          for (let i = 0; i < galaxyPositions.length; i += 3) {
            const radius = Math.sqrt(galaxyPositions[i] * galaxyPositions[i] + galaxyPositions[i + 2] * galaxyPositions[i + 2]);
            galaxyPositions[i + 1] = Math.sin(time * 2 + radius * 0.1) * 0.5;
          }
          galaxySystem.geometry.attributes.position.needsUpdate = true;
        }
        
        if (quantumField && quantumField.visible) {
          quantumField.material.uniforms.time.value = time;
          quantumField.material.uniforms.mousePos.value.set(mouseX * 0.5 + 0.5, mouseY * 0.5 + 0.5);
        }
        
        if (holographicDisplay && holographicDisplay.visible) {
          holographicDisplay.rotation.y += 0.01;
          holographicDisplay.children.forEach((child, index) => {
            if (child.material && child.material.uniforms) {
              child.material.uniforms.time.value = time;
              child.position.y = Math.sin(time + index) * 0.5;
            }
          });
        }
        
        if (neuralNetwork && neuralNetwork.group.visible) {
          // Animate nodes
          neuralNetwork.nodes.forEach((node, index) => {
            const pulse = Math.sin(time * 3 + index * 0.5) * 0.5 + 0.5;
            node.material.emissiveIntensity = pulse;
            node.scale.setScalar(1 + pulse * 0.2);
          });
          
          // Animate connections
          neuralNetwork.connections.forEach((conn, index) => {
            const pulse = Math.sin(time * 5 + index * 0.3) * 0.5 + 0.5;
            conn.line.material.opacity = 0.1 + pulse * 0.4;
          });
          
          neuralNetwork.group.rotation.y += 0.002;
        }
        
        if (matrixRain && matrixRain.visible) {
          matrixRain.children.forEach(drop => {
            drop.position.y -= drop.userData.speed;
            if (drop.position.y < -5) {
              drop.position.y = 10;
              drop.material.opacity = 1;
            } else {
              drop.material.opacity = Math.max(0, 1 - (10 - drop.position.y) / 15);
            }
          });
        }

        renderer.render(scene, camera);
      }

      // lastTime variable moved to animation function scope

      // Tab management
      let tabs = [];
      let activeTabId = null;
      let tabCounter = 0;
      let persistenceManager = null;
      let wakeLockManager = null;

      function generateTabId() {
        return `tab-${Date.now()}-${tabCounter++}`;
      }

      function createTab(title = "Terminal") {
        const tabId = generateTabId();
        const tab = {
          id: tabId,
          title: title,
          sessionId: null,
        };
        tabs.push(tab);

        // Create tab element
        const tabElement = document.createElement("div");
        tabElement.className = "tab";
        tabElement.id = `tab-${tabId}`;
        tabElement.innerHTML = `
                <span class="tab-title">${title}</span>
                <span class="tab-close" onclick="closeTab('${tabId}')">×</span>
            `;
        tabElement.onclick = (e) => {
          if (!e.target.classList.contains("tab-close")) {
            switchToTab(tabId);
          }
        };

        // Add before the add button
        const addBtn = document.querySelector(".add-tab-btn");
        addBtn.parentNode.insertBefore(tabElement, addBtn);

        // Create terminal iframe
        const iframe = document.createElement("iframe");
        iframe.id = `terminal-${tabId}`;
        iframe.style.width = "100%";
        iframe.style.height = "100%";
        iframe.style.border = "none";
        iframe.style.position = "absolute";
        iframe.style.top = "0";
        iframe.style.left = "0";
        iframe.style.display = "none";
        document.getElementById("terminals-container").appendChild(iframe);

        // Register with persistence manager
        if (persistenceManager) {
          persistenceManager.registerTab(tabId, iframe);
        }

        return tabId;
      }

      function switchToTab(tabId) {
        // Hide all terminals and deactivate all tabs
        tabs.forEach((tab) => {
          const tabElement = document.getElementById(`tab-${tab.id}`);
          const terminal = document.getElementById(`terminal-${tab.id}`);
          if (tabElement) tabElement.classList.remove("active");
          if (terminal) terminal.style.display = "none";
        });

        // Show selected tab and terminal
        const tabElement = document.getElementById(`tab-${tabId}`);
        const terminal = document.getElementById(`terminal-${tabId}`);
        if (tabElement) tabElement.classList.add("active");
        if (terminal) terminal.style.display = "block";

        activeTabId = tabId;

        // Load terminal if not already loaded
        const tab = tabs.find((t) => t.id === tabId);
        if (tab && !tab.sessionId) {
          loadTerminalForTab(tabId);
        }
      }

      function closeTab(tabId) {
        if (tabs.length <= 1) {
          alert("Cannot close the last tab");
          return;
        }

        // Remove tab from array
        const tabIndex = tabs.findIndex((t) => t.id === tabId);
        if (tabIndex === -1) return;

        tabs.splice(tabIndex, 1);

        // Remove elements
        const tabElement = document.getElementById(`tab-${tabId}`);
        const terminal = document.getElementById(`terminal-${tabId}`);
        if (tabElement) tabElement.remove();
        if (terminal) terminal.remove();

        // Unregister from persistence manager
        if (persistenceManager) {
          persistenceManager.unregisterTab(tabId);
        }

        // Switch to another tab if this was active
        if (activeTabId === tabId && tabs.length > 0) {
          switchToTab(tabs[0].id);
        }
      }

      function addNewTab() {
        const tabNumber = tabs.length + 1;
        const tabId = createTab(`Terminal ${tabNumber}`);
        switchToTab(tabId);
      }

      async function loadTerminalForTab(tabId) {
        const tab = tabs.find((t) => t.id === tabId);
        if (!tab) return;

        try {
          const frame = document.getElementById(`terminal-${tabId}`);
          // Use exec terminal with command execution
          frame.src = `/exec-terminal.html?session=${tabId}`;
          tab.sessionId = tabId;

          frame.onload = () => {
            setTimeout(() => {
              enhanceTerminal(frame);
              // Re-register with persistence manager after reload
              if (persistenceManager) {
                persistenceManager.registerTab(tabId, frame);
              }
              
              // Listen for commands from terminal iframe
              window.addEventListener('message', (event) => {
                if (event.data && event.data.type === 'command') {
                  triggerCommandEffect(event.data.command);
                }
              });
            }, 100);
          };
        } catch (error) {
          console.error("Failed to load terminal:", error);
        }
      }

      // Terminal functionality
      async function initTerminal() {
        // Hide loading screen first
        setTimeout(() => {
          document.getElementById("loadingScreen").style.opacity = "0";
          setTimeout(() => {
            document.getElementById("loadingScreen").style.display = "none";
          }, 500);
        }, 500);

        // Create first tab
        const firstTabId = createTab("Terminal 1");
        switchToTab(firstTabId);
      }

      function sendCmd(cmd) {
        if (!activeTabId) return;

        const frame = document.getElementById(`terminal-${activeTabId}`);
        if (!frame || !frame.contentWindow) {
          console.error("Terminal frame not ready");
          return;
        }
        
        // Trigger 3D effects based on command
        triggerCommandEffect(cmd);

        // Try multiple methods to send the command
        try {
          // Method 1: Direct ttyd API if available
          if (frame.contentWindow.term && frame.contentWindow.term.paste) {
            frame.contentWindow.term.paste(cmd);
            return;
          }

          // Method 2: Send via ttyd's input method
          if (frame.contentWindow.send) {
            frame.contentWindow.send(cmd);
            return;
          }

          // Method 3: Dispatch keyboard events
          const doc = frame.contentDocument || frame.contentWindow.document;
          const activeElement = doc.activeElement || doc.body;

          for (let i = 0; i < cmd.length; i++) {
            const char = cmd[i];
            const keyEvent = new KeyboardEvent("keypress", {
              key: char,
              charCode: char.charCodeAt(0),
              keyCode: char.charCodeAt(0),
              which: char.charCodeAt(0),
              bubbles: true,
            });
            activeElement.dispatchEvent(keyEvent);
          }
        } catch (e) {
          console.error("Failed to send command:", e);

          // Fallback: Try to focus the terminal and use execCommand
          try {
            frame.contentWindow.focus();
            frame.contentDocument.execCommand("insertText", false, cmd);
          } catch (e2) {
            console.error("Fallback also failed:", e2);
          }
        }
      }

      async function logout() {
        // Check if reboot on logout is enabled
        const config = await fetch("/api/terminal-config").then(r => r.json()).catch(() => ({}));
        const rebootEnabled = config.rebootOnLogout;
        
        const confirmMessage = rebootEnabled 
          ? "⚠️ Warning: Logging out will REBOOT the system!\n\nAre you sure you want to proceed?"
          : "Are you sure you want to log out?";
        
        if (confirm(confirmMessage)) {
          await fetch("/api/logout", { method: "POST" });
          window.location.href = "/login";
        }
      }

      // PWA Support
      let deferredPrompt;

      window.addEventListener("beforeinstallprompt", (e) => {
        e.preventDefault();
        deferredPrompt = e;
        document.getElementById("installPrompt").style.display = "flex";
      });

      function installPWA() {
        if (deferredPrompt) {
          deferredPrompt.prompt();
          deferredPrompt.userChoice.then((choiceResult) => {
            if (choiceResult.outcome === "accepted") {
              console.log("PWA installed");
            }
            deferredPrompt = null;
            document.getElementById("installPrompt").style.display = "none";
          });
        }
      }

      function dismissInstall() {
        document.getElementById("installPrompt").style.display = "none";
      }

      // Service Worker and Persistence Manager
      if ("serviceWorker" in navigator) {
        navigator.serviceWorker.register("/sw.js").then((reg) => {
          console.log("Service Worker registered");
          
          // Initialize persistence manager after service worker is ready
          navigator.serviceWorker.ready.then(() => {
            persistenceManager = new TerminalPersistenceManager();
            console.log("Terminal persistence manager initialized");
            
            // Initialize wake lock manager
            wakeLockManager = new WakeLockManager();
            console.log("Wake lock manager initialized");
            
            // Register existing tabs
            tabs.forEach(tab => {
              const iframe = document.getElementById(`terminal-${tab.id}`);
              if (iframe) {
                persistenceManager.registerTab(tab.id, iframe);
              }
            });
          });
        });
      }

      // Window resize
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Debug terminal iframe
      function debugTerminal() {
        if (!activeTabId) {
          console.log("No active tab");
          return;
        }

        const frame = document.getElementById(`terminal-${activeTabId}`);
        if (!frame) {
          console.log("No terminal frame found for tab:", activeTabId);
          return;
        }

        console.log("Terminal frame:", frame);
        console.log("Frame src:", frame.src);
        console.log("Frame contentWindow:", frame.contentWindow);

        try {
          console.log("Frame document:", frame.contentDocument);
          console.log("Available in frame:", Object.keys(frame.contentWindow));

          // Look for ttyd specific objects
          if (frame.contentWindow.term) {
            console.log("Found term object:", frame.contentWindow.term);
          }
          if (frame.contentWindow.Terminal) {
            console.log("Found Terminal constructor");
          }
          if (frame.contentWindow.fit) {
            console.log("Found fit addon");
          }
        } catch (e) {
          console.log("Cannot access frame content (cross-origin):", e.message);
        }
      }

      // Make debug function globally available
      window.debugTerminal = debugTerminal;

      // Enhance terminal with better UX
      function enhanceTerminal(frame) {
        if (!frame || !frame.contentWindow) return;

        try {
          const doc = frame.contentDocument || frame.contentWindow.document;

          // Inject custom CSS for syntax highlighting
          const style = doc.createElement("style");
          style.textContent = `
                    /* Syntax highlighting for common commands */
                    .xterm-screen span {
                        transition: color 0.2s ease;
                    }
                    
                    /* Command highlighting */
                    .xterm-screen [data-text*="git"],
                    .xterm-screen [data-text*="npm"],
                    .xterm-screen [data-text*="python"],
                    .xterm-screen [data-text*="node"],
                    .xterm-screen [data-text*="cd"],
                    .xterm-screen [data-text*="ls"],
                    .xterm-screen [data-text*="mkdir"],
                    .xterm-screen [data-text*="rm"],
                    .xterm-screen [data-text*="cp"],
                    .xterm-screen [data-text*="mv"] {
                        color: #7aa2f7 !important;
                        font-weight: bold;
                    }
                    
                    /* String highlighting */
                    .xterm-screen [data-text*="'"],
                    .xterm-screen [data-text*='"'] {
                        color: #9ece6a !important;
                    }
                    
                    /* Path highlighting */
                    .xterm-screen [data-text*="/"] {
                        color: #bb9af7 !important;
                    }
                    
                    /* Add subtle cursor animation */
                    .xterm-cursor-layer {
                        animation: cursorPulse 1s ease-in-out infinite;
                    }
                    
                    @keyframes cursorPulse {
                        0%, 100% { opacity: 1; }
                        50% { opacity: 0.7; }
                    }
                    
                    /* Terminal padding adjustment */
                    .xterm-screen {
                        padding: 10px !important;
                    }
                    
                    /* Smooth scrolling */
                    .xterm-viewport {
                        scroll-behavior: smooth;
                    }
                `;
          doc.head.appendChild(style);

          // Add keyboard shortcuts info
          if (frame.contentWindow.term) {
            console.log("Terminal enhanced with custom styling");
            
            // Intercept terminal input for 3D effects
            let commandBuffer = '';
            const term = frame.contentWindow.term;
            
            if (term && term.onData) {
              term.onData((data) => {
                if (data === '\r' || data === '\n') {
                  // Command was executed
                  triggerCommandEffect(commandBuffer);
                  commandBuffer = '';
                } else if (data === '\x7f') {
                  // Backspace
                  commandBuffer = commandBuffer.slice(0, -1);
                } else if (data.charCodeAt(0) >= 32) {
                  // Regular character
                  commandBuffer += data;
                }
              });
            }
          }
        } catch (e) {
          console.log("Could not enhance terminal (cross-origin):", e.message);
        }
      }

      // Global terminal enhancement for ttyd
      window.enhanceTerminal = enhanceTerminal;

      // Initialize when page is fully loaded
      window.addEventListener("DOMContentLoaded", () => {
        console.log("DOM loaded, checking THREE.js...");
        // Check if THREE is loaded
        if (typeof THREE !== "undefined") {
          console.log("THREE.js found, initializing...");
          initThree();
        } else {
          console.log("THREE.js not found yet, waiting...");
          // Fallback: wait for script to load
          let attempts = 0;
          const checkThree = setInterval(() => {
            attempts++;
            if (typeof THREE !== "undefined") {
              console.log("THREE.js loaded after", attempts, "attempts");
              clearInterval(checkThree);
              initThree();
            } else if (attempts > 50) {
              console.error("THREE.js failed to load after 5 seconds");
              clearInterval(checkThree);
            }
          }, 100);
        }
        initTerminal();
      });
    </script>
  </body>
</html>
